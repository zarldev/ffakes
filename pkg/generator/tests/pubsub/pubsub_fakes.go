// Code generated by ffakes v0.0.7 DO NOT EDIT.

package pubsub

import (
	"testing"
)

var (
	_ Publisher  = (*FakePublisher)(nil)
	_ Subscriber = (*FakeSubscriber)(nil)
	_ Broker     = (*FakeBroker)(nil)
)

type FakePublisher struct {
	t                   *testing.T
	PublishMessageCount int
	FPublishMessage     []func(m *Message) error
}

type PublishMessageFunc = func(m *Message) error
type PublisherOption func(f *FakePublisher)

func OnPublishMessage(fn ...PublishMessageFunc) PublisherOption {
	return func(f *FakePublisher) {
		f.FPublishMessage = append(f.FPublishMessage, fn...)
	}
}

func (f *FakePublisher) OnPublishMessage(fns ...PublishMessageFunc) {
	f.FPublishMessage = append(f.FPublishMessage, fns...)
}

func NewFakePublisher(t *testing.T, opts ...PublisherOption) *FakePublisher {
	f := &FakePublisher{t: t}
	for _, opt := range opts {
		opt(f)
	}
	t.Cleanup(func() {
		if f.PublishMessageCount != len(f.FPublishMessage) {
			t.Fatalf("expected PublishMessage to be called %d times but got %d", len(f.FPublishMessage), f.PublishMessageCount)
		}
	})
	return f
}

func (fake *FakePublisher) PublishMessage(m *Message) error {
	var idx = fake.PublishMessageCount
	if fake.PublishMessageCount >= len(fake.FPublishMessage) {
		idx = len(fake.FPublishMessage) - 1
	}
	if len(fake.FPublishMessage) != 0 {
		o1 := fake.FPublishMessage[idx](m)
		fake.PublishMessageCount++
		return o1
	}
	return nil
}

type FakeSubscriber struct {
	t                        *testing.T
	SubscribeToMessagesCount int
	FSubscribeToMessages     []func() (chan *Message, error)
}

type SubscribeToMessagesFunc = func() (chan *Message, error)
type SubscriberOption func(f *FakeSubscriber)

func OnSubscribeToMessages(fn ...SubscribeToMessagesFunc) SubscriberOption {
	return func(f *FakeSubscriber) {
		f.FSubscribeToMessages = append(f.FSubscribeToMessages, fn...)
	}
}

func (f *FakeSubscriber) OnSubscribeToMessages(fns ...SubscribeToMessagesFunc) {
	f.FSubscribeToMessages = append(f.FSubscribeToMessages, fns...)
}

func NewFakeSubscriber(t *testing.T, opts ...SubscriberOption) *FakeSubscriber {
	f := &FakeSubscriber{t: t}
	for _, opt := range opts {
		opt(f)
	}
	t.Cleanup(func() {
		if f.SubscribeToMessagesCount != len(f.FSubscribeToMessages) {
			t.Fatalf("expected SubscribeToMessages to be called %d times but got %d", len(f.FSubscribeToMessages), f.SubscribeToMessagesCount)
		}
	})
	return f
}

func (fake *FakeSubscriber) SubscribeToMessages() (chan *Message, error) {
	var idx = fake.SubscribeToMessagesCount
	if fake.SubscribeToMessagesCount >= len(fake.FSubscribeToMessages) {
		idx = len(fake.FSubscribeToMessages) - 1
	}
	if len(fake.FSubscribeToMessages) != 0 {
		o1, o2 := fake.FSubscribeToMessages[idx]()
		fake.SubscribeToMessagesCount++
		return o1, o2
	}
	return nil, nil
}

type FakeBroker struct {
	t                        *testing.T
	BrokerConnectionCount    int
	PublishMessageCount      int
	SubscribeToMessagesCount int
	FBrokerConnection        []func() error
	FPublishMessage          []func(m *Message) error
	FSubscribeToMessages     []func() (chan *Message, error)
}

type BrokerConnectionFunc = func() error
type BrokerOption func(f *FakeBroker)

func BrokerOnBrokerConnection(fn ...BrokerConnectionFunc) BrokerOption {
	return func(f *FakeBroker) {
		f.FBrokerConnection = append(f.FBrokerConnection, fn...)
	}
}

func BrokerOnPublishMessage(fn ...PublishMessageFunc) BrokerOption {
	return func(f *FakeBroker) {
		f.FPublishMessage = append(f.FPublishMessage, fn...)
	}
}

func BrokerOnSubscribeToMessages(fn ...SubscribeToMessagesFunc) BrokerOption {
	return func(f *FakeBroker) {
		f.FSubscribeToMessages = append(f.FSubscribeToMessages, fn...)
	}
}

func (f *FakeBroker) OnBrokerConnection(fns ...BrokerConnectionFunc) {
	f.FBrokerConnection = append(f.FBrokerConnection, fns...)
}

func (f *FakeBroker) OnPublishMessage(fns ...PublishMessageFunc) {
	f.FPublishMessage = append(f.FPublishMessage, fns...)
}

func (f *FakeBroker) OnSubscribeToMessages(fns ...SubscribeToMessagesFunc) {
	f.FSubscribeToMessages = append(f.FSubscribeToMessages, fns...)
}

func NewFakeBroker(t *testing.T, opts ...BrokerOption) *FakeBroker {
	f := &FakeBroker{t: t}
	for _, opt := range opts {
		opt(f)
	}
	t.Cleanup(func() {
		if f.BrokerConnectionCount != len(f.FBrokerConnection) {
			t.Fatalf("expected BrokerConnection to be called %d times but got %d", len(f.FBrokerConnection), f.BrokerConnectionCount)
		}
		if f.PublishMessageCount != len(f.FPublishMessage) {
			t.Fatalf("expected PublishMessage to be called %d times but got %d", len(f.FPublishMessage), f.PublishMessageCount)
		}
		if f.SubscribeToMessagesCount != len(f.FSubscribeToMessages) {
			t.Fatalf("expected SubscribeToMessages to be called %d times but got %d", len(f.FSubscribeToMessages), f.SubscribeToMessagesCount)
		}
	})
	return f
}

func (fake *FakeBroker) BrokerConnection() error {
	var idx = fake.BrokerConnectionCount
	if fake.BrokerConnectionCount >= len(fake.FBrokerConnection) {
		idx = len(fake.FBrokerConnection) - 1
	}
	if len(fake.FBrokerConnection) != 0 {
		o1 := fake.FBrokerConnection[idx]()
		fake.BrokerConnectionCount++
		return o1
	}
	return nil
}

func (fake *FakeBroker) PublishMessage(m *Message) error {
	var idx = fake.PublishMessageCount
	if fake.PublishMessageCount >= len(fake.FPublishMessage) {
		idx = len(fake.FPublishMessage) - 1
	}
	if len(fake.FPublishMessage) != 0 {
		o1 := fake.FPublishMessage[idx](m)
		fake.PublishMessageCount++
		return o1
	}
	return nil
}

func (fake *FakeBroker) SubscribeToMessages() (chan *Message, error) {
	var idx = fake.SubscribeToMessagesCount
	if fake.SubscribeToMessagesCount >= len(fake.FSubscribeToMessages) {
		idx = len(fake.FSubscribeToMessages) - 1
	}
	if len(fake.FSubscribeToMessages) != 0 {
		o1, o2 := fake.FSubscribeToMessages[idx]()
		fake.SubscribeToMessagesCount++
		return o1, o2
	}
	return nil, nil
}
